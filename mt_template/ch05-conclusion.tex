\chapter{Conclusion}

The basic functionality of computing trajectories according to input data works well. The visualization and analysis parts ended up rather limited due to time constraints.

When comparing to LAGRANTO, better performance and arguably better results have been achieved. The plots in section \ref{sec:quality} were not particularly helpful for anything beyond confirming that we can produce the same results. Intuitively, removing a bug from LAGRANTO and using an integrator with lower error bounds should only improve the results. A better analysis would be possible with a test setup using a completely artificial $UVW$ with a known ground truth.

There are some LAGRANTO features that are missing but would be quite simple to add: LAGRANTO uses a file to read the initial points. We let the user define them at the start and also write them into a separate file that can be used for LAGRANTO later. LAGRANTO also includes options like writing down only a subset of the computed points (useful for small timesteps), changing the timestep between files, or writing the output in a different format (for example as a text file). As mentioned in the introduction, LAGRANTO can work with input data that is not in the COSMO format.

Even though we can reproduce the LAGRANTO trajectories almost exactly for the most part, there are still some differences: Points outside the domain are not handled the same way as in LAGRANTO. Another issue is that LAGRANTO uses fixed units for certain variables (e.g. temperature in Celsius) whereas our code simply uses the values from the data files.

While the particle tracer works, it can still be extended. Because the region of interest for this project was relatively small and compact, the solver can not handle trajectories that reach the boundaries of the coordinate system (poles, date line). Some complications already occur at the borders of the local domain. Particles near the ground and outside the ($rlon$,$rlat$)-domain are handled differently between LAGRANTO and our code and both methods lead to undesirable results sometimes. The parallelization of the solver is currently very simple and could most likely be improved in more than one way.

The visualization with VTK is limited. While it is possible to read trajectories and show how they pass over the landscape, most settings are hardcoded. Displaying different trajectories or changing the variables requires changing the code. Optimally this would have been done using a GUI. Currently all loaded trajectories are displayed at once and there is no way to, for example, select only those that pass through a certain region or those with a certain average temperature.

Although it is possible to obtain trajectories and look at them, we did not look into the non-technical results very much. The search for interesting events would become much easier if the visualization tool was extended first. For the time being, we mostly found common features like wave-shaped trajectories.

%Originally there were plans for more postprocessing, visitation maps, finding cool stuff in the visualization...TODO

%\section{old)}
%looking at the task description: hmmm, originally it was more about visualizing and looking for features

%Overall, it's fine. It is possible to compute trajectories and view them without bugs. Performance-wise, our code runs significantly faster than LAGRANTO.

%There are several possible extensions:

%- Improving the input interface so it is possible to read most parameters from files instead of entering them manually each time

%- Parallelizing more: Currently the loop for propagating all trajectories is parallelized with OpenMP in a very simple manner. That is all.

%- Better solver: Who knows if I really did it right?

%- Different outputs: Maybe you want something other than just points?

%- The viewer has only very basic functionality. Most settings are hardcoded and there is no GUI to speak of.


